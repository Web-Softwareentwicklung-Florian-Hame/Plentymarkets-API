/*
Plentymarkets-API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiRestCategoriesGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	page *int32
}

// Limits the results to a specific page.
func (r ApiRestCategoriesGetRequest) Page(page int32) ApiRestCategoriesGetRequest {
	r.page = &page
	return r
}

func (r ApiRestCategoriesGetRequest) Execute() (CategoryPagination, *_nethttp.Response, error) {
	return r.ApiService.RestCategoriesGetExecute(r)
}

/*
RestCategoriesGet fetching categories with pagination and optional filter queries

fetching categories

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestCategoriesGetRequest
*/
func (a *DefaultApiService) RestCategoriesGet(ctx _context.Context) ApiRestCategoriesGetRequest {
	return ApiRestCategoriesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CategoryPagination
func (a *DefaultApiService) RestCategoriesGetExecute(r ApiRestCategoriesGetRequest) (CategoryPagination, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CategoryPagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestCategoriesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestCategoriesPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	category *[]Category
}

func (r ApiRestCategoriesPostRequest) Category(category []Category) ApiRestCategoriesPostRequest {
	r.category = &category
	return r
}

func (r ApiRestCategoriesPostRequest) Execute() ([]Category, *_nethttp.Response, error) {
	return r.ApiService.RestCategoriesPostExecute(r)
}

/*
RestCategoriesPost creating new categories

creating new categories

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestCategoriesPostRequest
*/
func (a *DefaultApiService) RestCategoriesPost(ctx _context.Context) ApiRestCategoriesPostRequest {
	return ApiRestCategoriesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Category
func (a *DefaultApiService) RestCategoriesPostExecute(r ApiRestCategoriesPostRequest) ([]Category, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Category
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestCategoriesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/categories"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.category
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestItemsAttributeValuesValueIdNamesPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	valueId int32
	attributeName *AttributeName
}

func (r ApiRestItemsAttributeValuesValueIdNamesPostRequest) AttributeName(attributeName AttributeName) ApiRestItemsAttributeValuesValueIdNamesPostRequest {
	r.attributeName = &attributeName
	return r
}

func (r ApiRestItemsAttributeValuesValueIdNamesPostRequest) Execute() (AttributeName, *_nethttp.Response, error) {
	return r.ApiService.RestItemsAttributeValuesValueIdNamesPostExecute(r)
}

/*
RestItemsAttributeValuesValueIdNamesPost creating attribute values names

creating attribute values names

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param valueId
 @return ApiRestItemsAttributeValuesValueIdNamesPostRequest
*/
func (a *DefaultApiService) RestItemsAttributeValuesValueIdNamesPost(ctx _context.Context, valueId int32) ApiRestItemsAttributeValuesValueIdNamesPostRequest {
	return ApiRestItemsAttributeValuesValueIdNamesPostRequest{
		ApiService: a,
		ctx: ctx,
		valueId: valueId,
	}
}

// Execute executes the request
//  @return AttributeName
func (a *DefaultApiService) RestItemsAttributeValuesValueIdNamesPostExecute(r ApiRestItemsAttributeValuesValueIdNamesPostRequest) (AttributeName, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeName
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestItemsAttributeValuesValueIdNamesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/items/attribute_values/{valueId}/names"
	localVarPath = strings.Replace(localVarPath, "{"+"valueId"+"}", _neturl.PathEscape(parameterToString(r.valueId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attributeName
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestItemsAttributesAttributeIdNamesPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	attributeId int32
	attributeName *AttributeName
}

func (r ApiRestItemsAttributesAttributeIdNamesPostRequest) AttributeName(attributeName AttributeName) ApiRestItemsAttributesAttributeIdNamesPostRequest {
	r.attributeName = &attributeName
	return r
}

func (r ApiRestItemsAttributesAttributeIdNamesPostRequest) Execute() (AttributeName, *_nethttp.Response, error) {
	return r.ApiService.RestItemsAttributesAttributeIdNamesPostExecute(r)
}

/*
RestItemsAttributesAttributeIdNamesPost creating names for attribute

creating names for attribute

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attributeId
 @return ApiRestItemsAttributesAttributeIdNamesPostRequest
*/
func (a *DefaultApiService) RestItemsAttributesAttributeIdNamesPost(ctx _context.Context, attributeId int32) ApiRestItemsAttributesAttributeIdNamesPostRequest {
	return ApiRestItemsAttributesAttributeIdNamesPostRequest{
		ApiService: a,
		ctx: ctx,
		attributeId: attributeId,
	}
}

// Execute executes the request
//  @return AttributeName
func (a *DefaultApiService) RestItemsAttributesAttributeIdNamesPostExecute(r ApiRestItemsAttributesAttributeIdNamesPostRequest) (AttributeName, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeName
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestItemsAttributesAttributeIdNamesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/items/attributes/{attributeId}/names"
	localVarPath = strings.Replace(localVarPath, "{"+"attributeId"+"}", _neturl.PathEscape(parameterToString(r.attributeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attributeName
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestItemsAttributesAttributeIdValuesGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	attributeId int32
	page *int32
	with *[]string
}

// Limits the results to a specific page.
func (r ApiRestItemsAttributesAttributeIdValuesGetRequest) Page(page int32) ApiRestItemsAttributesAttributeIdValuesGetRequest {
	r.page = &page
	return r
}
func (r ApiRestItemsAttributesAttributeIdValuesGetRequest) With(with []string) ApiRestItemsAttributesAttributeIdValuesGetRequest {
	r.with = &with
	return r
}

func (r ApiRestItemsAttributesAttributeIdValuesGetRequest) Execute() (AttributeValuePagination, *_nethttp.Response, error) {
	return r.ApiService.RestItemsAttributesAttributeIdValuesGetExecute(r)
}

/*
RestItemsAttributesAttributeIdValuesGet fetching attributes values with pagination

fetching attributes values with pagination

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attributeId
 @return ApiRestItemsAttributesAttributeIdValuesGetRequest
*/
func (a *DefaultApiService) RestItemsAttributesAttributeIdValuesGet(ctx _context.Context, attributeId int32) ApiRestItemsAttributesAttributeIdValuesGetRequest {
	return ApiRestItemsAttributesAttributeIdValuesGetRequest{
		ApiService: a,
		ctx: ctx,
		attributeId: attributeId,
	}
}

// Execute executes the request
//  @return AttributeValuePagination
func (a *DefaultApiService) RestItemsAttributesAttributeIdValuesGetExecute(r ApiRestItemsAttributesAttributeIdValuesGetRequest) (AttributeValuePagination, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeValuePagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestItemsAttributesAttributeIdValuesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/items/attributes/{attributeId}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"attributeId"+"}", _neturl.PathEscape(parameterToString(r.attributeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.with != nil {
		t := *r.with
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("with", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("with", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestItemsAttributesAttributeIdValuesPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	attributeId int32
	attributeValue *AttributeValue
}

func (r ApiRestItemsAttributesAttributeIdValuesPostRequest) AttributeValue(attributeValue AttributeValue) ApiRestItemsAttributesAttributeIdValuesPostRequest {
	r.attributeValue = &attributeValue
	return r
}

func (r ApiRestItemsAttributesAttributeIdValuesPostRequest) Execute() (AttributeValue, *_nethttp.Response, error) {
	return r.ApiService.RestItemsAttributesAttributeIdValuesPostExecute(r)
}

/*
RestItemsAttributesAttributeIdValuesPost creating new attribute values

creating new attribute values

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attributeId
 @return ApiRestItemsAttributesAttributeIdValuesPostRequest
*/
func (a *DefaultApiService) RestItemsAttributesAttributeIdValuesPost(ctx _context.Context, attributeId int32) ApiRestItemsAttributesAttributeIdValuesPostRequest {
	return ApiRestItemsAttributesAttributeIdValuesPostRequest{
		ApiService: a,
		ctx: ctx,
		attributeId: attributeId,
	}
}

// Execute executes the request
//  @return AttributeValue
func (a *DefaultApiService) RestItemsAttributesAttributeIdValuesPostExecute(r ApiRestItemsAttributesAttributeIdValuesPostRequest) (AttributeValue, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestItemsAttributesAttributeIdValuesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/items/attributes/{attributeId}/values"
	localVarPath = strings.Replace(localVarPath, "{"+"attributeId"+"}", _neturl.PathEscape(parameterToString(r.attributeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attributeValue
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestItemsAttributesGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	page *int32
	with *[]string
}

// Limits the results to a specific page.
func (r ApiRestItemsAttributesGetRequest) Page(page int32) ApiRestItemsAttributesGetRequest {
	r.page = &page
	return r
}
func (r ApiRestItemsAttributesGetRequest) With(with []string) ApiRestItemsAttributesGetRequest {
	r.with = &with
	return r
}

func (r ApiRestItemsAttributesGetRequest) Execute() (AttributePagination, *_nethttp.Response, error) {
	return r.ApiService.RestItemsAttributesGetExecute(r)
}

/*
RestItemsAttributesGet fetching attributes with pagination

fetching attributes with pagination

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestItemsAttributesGetRequest
*/
func (a *DefaultApiService) RestItemsAttributesGet(ctx _context.Context) ApiRestItemsAttributesGetRequest {
	return ApiRestItemsAttributesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributePagination
func (a *DefaultApiService) RestItemsAttributesGetExecute(r ApiRestItemsAttributesGetRequest) (AttributePagination, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributePagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestItemsAttributesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/items/attributes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.with != nil {
		t := *r.with
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("with", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("with", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestItemsAttributesPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	attribute *Attribute
}

func (r ApiRestItemsAttributesPostRequest) Attribute(attribute Attribute) ApiRestItemsAttributesPostRequest {
	r.attribute = &attribute
	return r
}

func (r ApiRestItemsAttributesPostRequest) Execute() (Attribute, *_nethttp.Response, error) {
	return r.ApiService.RestItemsAttributesPostExecute(r)
}

/*
RestItemsAttributesPost creating new attributes

creating new attributes

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestItemsAttributesPostRequest
*/
func (a *DefaultApiService) RestItemsAttributesPost(ctx _context.Context) ApiRestItemsAttributesPostRequest {
	return ApiRestItemsAttributesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Attribute
func (a *DefaultApiService) RestItemsAttributesPostExecute(r ApiRestItemsAttributesPostRequest) (Attribute, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Attribute
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestItemsAttributesPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/items/attributes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attribute
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestItemsGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	with *[]string
	lang *string
	page *int32
	itemsPerPage *int32
	name *string
	manufacturerId *int32
	id *[]int32
	flagOne *int32
	flagTwo *int32
	updatedBetween *string
	variationUpdatedBetween *string
	variationRelatedUpdatedBetween *string
	or *string
}

// Includes the specified variation information in the results
func (r ApiRestItemsGetRequest) With(with []string) ApiRestItemsGetRequest {
	r.with = &with
	return r
}
// The language of the variation information.
func (r ApiRestItemsGetRequest) Lang(lang string) ApiRestItemsGetRequest {
	r.lang = &lang
	return r
}
// Limits the results to a specific page.
func (r ApiRestItemsGetRequest) Page(page int32) ApiRestItemsGetRequest {
	r.page = &page
	return r
}
// Limits the number of results listed per page to a specific number.
func (r ApiRestItemsGetRequest) ItemsPerPage(itemsPerPage int32) ApiRestItemsGetRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}
// Filter restricts the list of results to items with the specified item name.
func (r ApiRestItemsGetRequest) Name(name string) ApiRestItemsGetRequest {
	r.name = &name
	return r
}
// Filter restricts the list of results to items with the specified manufacturerId.
func (r ApiRestItemsGetRequest) ManufacturerId(manufacturerId int32) ApiRestItemsGetRequest {
	r.manufacturerId = &manufacturerId
	return r
}
// Filter restricts the list of results to items with the specified ID. More than one ID should be separated by commas.
func (r ApiRestItemsGetRequest) Id(id []int32) ApiRestItemsGetRequest {
	r.id = &id
	return r
}
// Filter restricts the list of results to items with the specified flagOne.
func (r ApiRestItemsGetRequest) FlagOne(flagOne int32) ApiRestItemsGetRequest {
	r.flagOne = &flagOne
	return r
}
// Filter restricts the list of results to items with the specified flagTwo.
func (r ApiRestItemsGetRequest) FlagTwo(flagTwo int32) ApiRestItemsGetRequest {
	r.flagTwo = &flagTwo
	return r
}
// Filter restricts the list of results to items updated during the specified period. The end date (to) is optional. If no end date is specified, items updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items updated since 2016-01-01. The PHP function strtotime is also supported.
func (r ApiRestItemsGetRequest) UpdatedBetween(updatedBetween string) ApiRestItemsGetRequest {
	r.updatedBetween = &updatedBetween
	return r
}
// Filter restricts the list of results to items with variations that were updated during the specified period. The end date (to) is optional. If no end date is specified, items with variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../items?updatedBetween&#x3D;1451606400,1456790400 will list items with variations that were updated between 2016-01-01 and 2016-03-01. .../items?updatedBetween&#x3D;1451606400 will list items with variations that were updated since 2016-01-01. The PHP function strtotime is also supported.
func (r ApiRestItemsGetRequest) VariationUpdatedBetween(variationUpdatedBetween string) ApiRestItemsGetRequest {
	r.variationUpdatedBetween = &variationUpdatedBetween
	return r
}
// Filter restricts the list of results to items with variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats.
func (r ApiRestItemsGetRequest) VariationRelatedUpdatedBetween(variationRelatedUpdatedBetween string) ApiRestItemsGetRequest {
	r.variationRelatedUpdatedBetween = &variationRelatedUpdatedBetween
	return r
}
// Filters can be defined in this param to link them via OR instead of AND. The syntax looks like the following: or&#x3D;(updatedBetween&#x3D;1573050718&amp;varitionUpdatedBetween&#x3D;1573050718). Everything in the brackets is written in the normal URL-Syntax. The or-param can be used multiple times if it is used like this: or[]&#x3D;(...)&amp;or[]&#x3D;(...)
func (r ApiRestItemsGetRequest) Or(or string) ApiRestItemsGetRequest {
	r.or = &or
	return r
}

func (r ApiRestItemsGetRequest) Execute() ([]ItemPagination, *_nethttp.Response, error) {
	return r.ApiService.RestItemsGetExecute(r)
}

/*
RestItemsGet fetching items with optional extra data or filters given in query parameter

fetching items with optional extra data or filters given in query parameter

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestItemsGetRequest
*/
func (a *DefaultApiService) RestItemsGet(ctx _context.Context) ApiRestItemsGetRequest {
	return ApiRestItemsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ItemPagination
func (a *DefaultApiService) RestItemsGetExecute(r ApiRestItemsGetRequest) ([]ItemPagination, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ItemPagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestItemsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.with != nil {
		t := *r.with
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("with", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("with", parameterToString(t, "multi"))
		}
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.manufacturerId != nil {
		localVarQueryParams.Add("manufacturerId", parameterToString(*r.manufacturerId, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, "csv"))
	}
	if r.flagOne != nil {
		localVarQueryParams.Add("flagOne", parameterToString(*r.flagOne, ""))
	}
	if r.flagTwo != nil {
		localVarQueryParams.Add("flagTwo", parameterToString(*r.flagTwo, ""))
	}
	if r.updatedBetween != nil {
		localVarQueryParams.Add("updatedBetween", parameterToString(*r.updatedBetween, ""))
	}
	if r.variationUpdatedBetween != nil {
		localVarQueryParams.Add("variationUpdatedBetween", parameterToString(*r.variationUpdatedBetween, ""))
	}
	if r.variationRelatedUpdatedBetween != nil {
		localVarQueryParams.Add("variationRelatedUpdatedBetween", parameterToString(*r.variationRelatedUpdatedBetween, ""))
	}
	if r.or != nil {
		localVarQueryParams.Add("or", parameterToString(*r.or, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestItemsItemIdVariationsPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	itemId int32
	variation *[]Variation
}

func (r ApiRestItemsItemIdVariationsPostRequest) Variation(variation []Variation) ApiRestItemsItemIdVariationsPostRequest {
	r.variation = &variation
	return r
}

func (r ApiRestItemsItemIdVariationsPostRequest) Execute() (Variation, *_nethttp.Response, error) {
	return r.ApiService.RestItemsItemIdVariationsPostExecute(r)
}

/*
RestItemsItemIdVariationsPost creating variations for an item

creating variations for an item

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId numeric itemId of the item where the variations belongs to
 @return ApiRestItemsItemIdVariationsPostRequest
*/
func (a *DefaultApiService) RestItemsItemIdVariationsPost(ctx _context.Context, itemId int32) ApiRestItemsItemIdVariationsPostRequest {
	return ApiRestItemsItemIdVariationsPostRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return Variation
func (a *DefaultApiService) RestItemsItemIdVariationsPostExecute(r ApiRestItemsItemIdVariationsPostRequest) (Variation, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Variation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestItemsItemIdVariationsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/items/{itemId}/variations"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.PathEscape(parameterToString(r.itemId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.variation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestItemsManufacturersGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	with *[]string
	updatedAt *string
	name *string
}

func (r ApiRestItemsManufacturersGetRequest) With(with []string) ApiRestItemsManufacturersGetRequest {
	r.with = &with
	return r
}
// Filter restricts the list of results to records updated after the specified date. The date can be specified as unix timestamps or in the ISO 8601 date format. The PHP function strtotime is also supported.
func (r ApiRestItemsManufacturersGetRequest) UpdatedAt(updatedAt string) ApiRestItemsManufacturersGetRequest {
	r.updatedAt = &updatedAt
	return r
}
// Filter restricts the list of results to records with specified name.
func (r ApiRestItemsManufacturersGetRequest) Name(name string) ApiRestItemsManufacturersGetRequest {
	r.name = &name
	return r
}

func (r ApiRestItemsManufacturersGetRequest) Execute() (ManufacturersPagination, *_nethttp.Response, error) {
	return r.ApiService.RestItemsManufacturersGetExecute(r)
}

/*
RestItemsManufacturersGet list manufacturers

list manufacturers

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestItemsManufacturersGetRequest
*/
func (a *DefaultApiService) RestItemsManufacturersGet(ctx _context.Context) ApiRestItemsManufacturersGetRequest {
	return ApiRestItemsManufacturersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ManufacturersPagination
func (a *DefaultApiService) RestItemsManufacturersGetExecute(r ApiRestItemsManufacturersGetRequest) (ManufacturersPagination, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ManufacturersPagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestItemsManufacturersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/items/manufacturers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.with != nil {
		localVarQueryParams.Add("with", parameterToString(*r.with, "csv"))
	}
	if r.updatedAt != nil {
		localVarQueryParams.Add("updatedAt", parameterToString(*r.updatedAt, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestItemsManufacturersPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	manufacturer *Manufacturer
}

func (r ApiRestItemsManufacturersPostRequest) Manufacturer(manufacturer Manufacturer) ApiRestItemsManufacturersPostRequest {
	r.manufacturer = &manufacturer
	return r
}

func (r ApiRestItemsManufacturersPostRequest) Execute() (Manufacturer, *_nethttp.Response, error) {
	return r.ApiService.RestItemsManufacturersPostExecute(r)
}

/*
RestItemsManufacturersPost creates a manufacturer

creates a manufacturer

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestItemsManufacturersPostRequest
*/
func (a *DefaultApiService) RestItemsManufacturersPost(ctx _context.Context) ApiRestItemsManufacturersPostRequest {
	return ApiRestItemsManufacturersPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Manufacturer
func (a *DefaultApiService) RestItemsManufacturersPostExecute(r ApiRestItemsManufacturersPostRequest) (Manufacturer, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Manufacturer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestItemsManufacturersPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/items/manufacturers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.manufacturer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestItemsPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	item *[]Item
}

func (r ApiRestItemsPostRequest) Item(item []Item) ApiRestItemsPostRequest {
	r.item = &item
	return r
}

func (r ApiRestItemsPostRequest) Execute() ([]Item, *_nethttp.Response, error) {
	return r.ApiService.RestItemsPostExecute(r)
}

/*
RestItemsPost creates items

creates items

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestItemsPostRequest
*/
func (a *DefaultApiService) RestItemsPost(ctx _context.Context) ApiRestItemsPostRequest {
	return ApiRestItemsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Item
func (a *DefaultApiService) RestItemsPostExecute(r ApiRestItemsPostRequest) ([]Item, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Item
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestItemsPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.item
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestItemsVariationsGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	with *[]string
	lang *string
	page *int32
	itemsPerPage *int32
	id *[]int32
	itemId *[]int32
	variationTagId *[]int32
	itemName *string
	flagOne *int32
	flagTwo *int32
	storeSpecial *float32
	categoryId *int32
	isMain *bool
	isActive *bool
	barcode *string
	numberExact *string
	numberFuzzy *string
	isBundle *bool
	plentyId *[]int32
	referrerId *[]int32
	supplierNumber *string
	sku *string
	manufacturerId *int32
	updatedBetween *string
	createdBetween *string
	relatedUpdatedBetween *string
	itemDescription *string
	stockWarehouseId *string
	supplierId *int32
}

func (r ApiRestItemsVariationsGetRequest) With(with []string) ApiRestItemsVariationsGetRequest {
	r.with = &with
	return r
}
// The language of the variation information.
func (r ApiRestItemsVariationsGetRequest) Lang(lang string) ApiRestItemsVariationsGetRequest {
	r.lang = &lang
	return r
}
// Limits the results to a specific page.
func (r ApiRestItemsVariationsGetRequest) Page(page int32) ApiRestItemsVariationsGetRequest {
	r.page = &page
	return r
}
// Limits the number of results listed per page to a specific number.
func (r ApiRestItemsVariationsGetRequest) ItemsPerPage(itemsPerPage int32) ApiRestItemsVariationsGetRequest {
	r.itemsPerPage = &itemsPerPage
	return r
}
// Filter restricts the list of results to variations with the specified variation ID. An variation ID must be specified. More than one ID should be separated by commas.
func (r ApiRestItemsVariationsGetRequest) Id(id []int32) ApiRestItemsVariationsGetRequest {
	r.id = &id
	return r
}
// Filter restricts the list of results to variations with the specified item ID. An item ID must be specified. More than one ID should be separated by commas.
func (r ApiRestItemsVariationsGetRequest) ItemId(itemId []int32) ApiRestItemsVariationsGetRequest {
	r.itemId = &itemId
	return r
}
// Filter restricts the list of results to variations with the specified item name. An item name must be specified.
func (r ApiRestItemsVariationsGetRequest) VariationTagId(variationTagId []int32) ApiRestItemsVariationsGetRequest {
	r.variationTagId = &variationTagId
	return r
}
// Filter restricts the list of results to variations with the specified item name
func (r ApiRestItemsVariationsGetRequest) ItemName(itemName string) ApiRestItemsVariationsGetRequest {
	r.itemName = &itemName
	return r
}
// Filter restricts the list of results to variations of items with the flag one.
func (r ApiRestItemsVariationsGetRequest) FlagOne(flagOne int32) ApiRestItemsVariationsGetRequest {
	r.flagOne = &flagOne
	return r
}
// Filter restricts the list of results to variations of items with the flag two.
func (r ApiRestItemsVariationsGetRequest) FlagTwo(flagTwo int32) ApiRestItemsVariationsGetRequest {
	r.flagTwo = &flagTwo
	return r
}
// Filter restricts the list of results to variations of items with the specified store special. The following values are allowed: 0 (None), 1 (Special offer), 2 (New item), 3 (Top item)
func (r ApiRestItemsVariationsGetRequest) StoreSpecial(storeSpecial float32) ApiRestItemsVariationsGetRequest {
	r.storeSpecial = &storeSpecial
	return r
}
// Filter restricts the list of results to variations with the specified category id
func (r ApiRestItemsVariationsGetRequest) CategoryId(categoryId int32) ApiRestItemsVariationsGetRequest {
	r.categoryId = &categoryId
	return r
}
// Filter restricts the list of results to variations that are main variations.
func (r ApiRestItemsVariationsGetRequest) IsMain(isMain bool) ApiRestItemsVariationsGetRequest {
	r.isMain = &isMain
	return r
}
// Filter restricts the list of results to variations that are active.
func (r ApiRestItemsVariationsGetRequest) IsActive(isActive bool) ApiRestItemsVariationsGetRequest {
	r.isActive = &isActive
	return r
}
// Filter restricts the list of results to variations with the specified barcode.
func (r ApiRestItemsVariationsGetRequest) Barcode(barcode string) ApiRestItemsVariationsGetRequest {
	r.barcode = &barcode
	return r
}
// Filter restricts the list of results to the variation with the variation number specified.
func (r ApiRestItemsVariationsGetRequest) NumberExact(numberExact string) ApiRestItemsVariationsGetRequest {
	r.numberExact = &numberExact
	return r
}
// Filter restricts the list of results to variations with numbers that contain the variation number specified (SQL LIKE operator). For example, if variations with variation numbers 1 to 400 exist in the system, filtering by 12 will list variation numbers 12, 112, 120-129, 212 and 312.
func (r ApiRestItemsVariationsGetRequest) NumberFuzzy(numberFuzzy string) ApiRestItemsVariationsGetRequest {
	r.numberFuzzy = &numberFuzzy
	return r
}
// Filter restricts the list of results to variations to which variations were added to create a bundle.
func (r ApiRestItemsVariationsGetRequest) IsBundle(isBundle bool) ApiRestItemsVariationsGetRequest {
	r.isBundle = &isBundle
	return r
}
// Filter restricts the list of results to variations that are visible in specified clients. Separate more than one client by commas.
func (r ApiRestItemsVariationsGetRequest) PlentyId(plentyId []int32) ApiRestItemsVariationsGetRequest {
	r.plentyId = &plentyId
	return r
}
// Filter restricts the list of results to variations that are visible in specified markets. Separate more than one referrer by commas.
func (r ApiRestItemsVariationsGetRequest) ReferrerId(referrerId []int32) ApiRestItemsVariationsGetRequest {
	r.referrerId = &referrerId
	return r
}
// Filter restricts the list of results to variations with the specified supplier number.
func (r ApiRestItemsVariationsGetRequest) SupplierNumber(supplierNumber string) ApiRestItemsVariationsGetRequest {
	r.supplierNumber = &supplierNumber
	return r
}
// Filter restricts the list of results to variations with the specified SKU. In additional, results can also be restricted to a specific referrer by specifying the referrer ID after a colon. Example: L0R3MIP5UM:104.1
func (r ApiRestItemsVariationsGetRequest) Sku(sku string) ApiRestItemsVariationsGetRequest {
	r.sku = &sku
	return r
}
// Filter restricts the list of results to variations with the specified manufacturer ID.
func (r ApiRestItemsVariationsGetRequest) ManufacturerId(manufacturerId int32) ApiRestItemsVariationsGetRequest {
	r.manufacturerId = &manufacturerId
	return r
}
// Filter restricts the list of results to variations updated during the specified period. The end date (to) is optional. If no end date is specified, variations updated between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?updatedBetween&#x3D;1451606400,1456790400 will list variations updated between 2016-01-01 and 2016-03-01. .../variations?updatedBetween&#x3D;1451606400 will list variations updated since 2016-01-01. The PHP function strtotime is also supported.
func (r ApiRestItemsVariationsGetRequest) UpdatedBetween(updatedBetween string) ApiRestItemsVariationsGetRequest {
	r.updatedBetween = &updatedBetween
	return r
}
// Filter restricts the list of results to variations created during the specified period. The end date (to) is optional. If no end date is specified, variations created between the start date (from) and the present will be listed. The dates can be specified as unix timestamps or in the ISO 8601 date format. Start date and optional end date are separated by a comma. For example, .../variations?createdBetween&#x3D;1451606400,1456790400 will list variations created between 2016-01-01 and 2016-03-01. .../variations?createdBetween&#x3D;1451606400 will list variations created since 2016-01-01. The PHP function strtotime is also supported.
func (r ApiRestItemsVariationsGetRequest) CreatedBetween(createdBetween string) ApiRestItemsVariationsGetRequest {
	r.createdBetween = &createdBetween
	return r
}
// Filter restricts the list of results to those variations for which related information was updated during the specified period. Related information is defined as information linked to the variation, i.e. barcodes, categories, images, markets, clients (stores), prices, suppliers, warehouses and the default category. See variationUpdatedBetween for supported formats.
func (r ApiRestItemsVariationsGetRequest) RelatedUpdatedBetween(relatedUpdatedBetween string) ApiRestItemsVariationsGetRequest {
	r.relatedUpdatedBetween = &relatedUpdatedBetween
	return r
}
// Filter restricts the list of results to variations with descriptions that contain the specified string.
func (r ApiRestItemsVariationsGetRequest) ItemDescription(itemDescription string) ApiRestItemsVariationsGetRequest {
	r.itemDescription = &itemDescription
	return r
}
// Filter restricts the list of results to variations which have physical stock on the given warehouse.
func (r ApiRestItemsVariationsGetRequest) StockWarehouseId(stockWarehouseId string) ApiRestItemsVariationsGetRequest {
	r.stockWarehouseId = &stockWarehouseId
	return r
}
// Filter restricts the list of results to variations with the specified supplier ID.
func (r ApiRestItemsVariationsGetRequest) SupplierId(supplierId int32) ApiRestItemsVariationsGetRequest {
	r.supplierId = &supplierId
	return r
}

func (r ApiRestItemsVariationsGetRequest) Execute() (VariationPagination, *_nethttp.Response, error) {
	return r.ApiService.RestItemsVariationsGetExecute(r)
}

/*
RestItemsVariationsGet fetching variations with pagination and the possibility to fetch additional related data by 'with' query param

fetching variations

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestItemsVariationsGetRequest
*/
func (a *DefaultApiService) RestItemsVariationsGet(ctx _context.Context) ApiRestItemsVariationsGetRequest {
	return ApiRestItemsVariationsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VariationPagination
func (a *DefaultApiService) RestItemsVariationsGetExecute(r ApiRestItemsVariationsGetRequest) (VariationPagination, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VariationPagination
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestItemsVariationsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/items/variations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.with != nil {
		localVarQueryParams.Add("with", parameterToString(*r.with, "csv"))
	}
	if r.lang != nil {
		localVarQueryParams.Add("lang", parameterToString(*r.lang, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.itemsPerPage != nil {
		localVarQueryParams.Add("itemsPerPage", parameterToString(*r.itemsPerPage, ""))
	}
	if r.id != nil {
		localVarQueryParams.Add("id", parameterToString(*r.id, "csv"))
	}
	if r.itemId != nil {
		localVarQueryParams.Add("itemId", parameterToString(*r.itemId, "csv"))
	}
	if r.variationTagId != nil {
		localVarQueryParams.Add("variationTagId", parameterToString(*r.variationTagId, "csv"))
	}
	if r.itemName != nil {
		localVarQueryParams.Add("itemName", parameterToString(*r.itemName, ""))
	}
	if r.flagOne != nil {
		localVarQueryParams.Add("flagOne", parameterToString(*r.flagOne, ""))
	}
	if r.flagTwo != nil {
		localVarQueryParams.Add("flagTwo", parameterToString(*r.flagTwo, ""))
	}
	if r.storeSpecial != nil {
		localVarQueryParams.Add("storeSpecial", parameterToString(*r.storeSpecial, ""))
	}
	if r.categoryId != nil {
		localVarQueryParams.Add("categoryId", parameterToString(*r.categoryId, ""))
	}
	if r.isMain != nil {
		localVarQueryParams.Add("isMain", parameterToString(*r.isMain, ""))
	}
	if r.isActive != nil {
		localVarQueryParams.Add("isActive", parameterToString(*r.isActive, ""))
	}
	if r.barcode != nil {
		localVarQueryParams.Add("barcode", parameterToString(*r.barcode, ""))
	}
	if r.numberExact != nil {
		localVarQueryParams.Add("numberExact", parameterToString(*r.numberExact, ""))
	}
	if r.numberFuzzy != nil {
		localVarQueryParams.Add("numberFuzzy", parameterToString(*r.numberFuzzy, ""))
	}
	if r.isBundle != nil {
		localVarQueryParams.Add("isBundle", parameterToString(*r.isBundle, ""))
	}
	if r.plentyId != nil {
		localVarQueryParams.Add("plentyId", parameterToString(*r.plentyId, "csv"))
	}
	if r.referrerId != nil {
		localVarQueryParams.Add("referrerId", parameterToString(*r.referrerId, "csv"))
	}
	if r.supplierNumber != nil {
		localVarQueryParams.Add("supplierNumber", parameterToString(*r.supplierNumber, ""))
	}
	if r.sku != nil {
		localVarQueryParams.Add("sku", parameterToString(*r.sku, ""))
	}
	if r.manufacturerId != nil {
		localVarQueryParams.Add("manufacturerId", parameterToString(*r.manufacturerId, ""))
	}
	if r.updatedBetween != nil {
		localVarQueryParams.Add("updatedBetween", parameterToString(*r.updatedBetween, ""))
	}
	if r.createdBetween != nil {
		localVarQueryParams.Add("createdBetween", parameterToString(*r.createdBetween, ""))
	}
	if r.relatedUpdatedBetween != nil {
		localVarQueryParams.Add("relatedUpdatedBetween", parameterToString(*r.relatedUpdatedBetween, ""))
	}
	if r.itemDescription != nil {
		localVarQueryParams.Add("itemDescription", parameterToString(*r.itemDescription, ""))
	}
	if r.stockWarehouseId != nil {
		localVarQueryParams.Add("stockWarehouseId", parameterToString(*r.stockWarehouseId, ""))
	}
	if r.supplierId != nil {
		localVarQueryParams.Add("supplierId", parameterToString(*r.supplierId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestLoginPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	restLoginBody *RestLoginBody
}

func (r ApiRestLoginPostRequest) RestLoginBody(restLoginBody RestLoginBody) ApiRestLoginPostRequest {
	r.restLoginBody = &restLoginBody
	return r
}

func (r ApiRestLoginPostRequest) Execute() (RestLoginResponse, *_nethttp.Response, error) {
	return r.ApiService.RestLoginPostExecute(r)
}

/*
RestLoginPost login for authentication at rest api

needed for authenticate at the plentymarkets rest api

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestLoginPostRequest
*/
func (a *DefaultApiService) RestLoginPost(ctx _context.Context) ApiRestLoginPostRequest {
	return ApiRestLoginPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RestLoginResponse
func (a *DefaultApiService) RestLoginPostExecute(r ApiRestLoginPostRequest) (RestLoginResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RestLoginResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.RestLoginPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rest/login"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json;charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json;charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restLoginBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
